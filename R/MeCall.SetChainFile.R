#' Creating a reference file to convert between different versions of Illumina methylation microarray.
#'
#' @import stringr
#'
#' @description
#' This function aims to facilitate the conversion between different versions of Illumina methylation microarrays by generating a "chain file" that links the unique values of the same probes across different versions.
#'
#' Especially for EPICv2 data, users can validate and designate the list of duplicated probes generated by the user.
#'
#' Users can create a chain file by using pre-processed data included in `MethylCallR` or by providing custom data in a data frame object.
#' Then, `MethylCallR` will reference this file to convert versions of Illumina methylation microarrays.
#' 
#' If the user designates the created objects as global variables named `Address_chain_file` or `Duplicated.Probes.preset`, respectively, `MethylCallR` will automatically reference these files.
#' 
#' Ensure that the `Address_chain_file` and `Duplicated.Probes.preset` are not masked by an external package or data.
#' 
#' @param remove.list A data frame containing "AddressA_ID" and "AddressB_ID" as column names and probe ID as row names. A subset of the Illumina manifest is highly recommended.
#' @param auto.remove logical. If set to `TRUE`, probes in the duplicated probe sets that are not addressed in the user-provided file are automatically removed based on the pre-set file implemented in `MethylCallR`.
#' @param global.env logical. If set to `TRUE`, returm object will be imported into global environment of R. If set to `FALSE`, function will return a data frame object.
#'
#' @return A list object containing the user-specified list of duplicated probes for removal 
#' and the address chain file generated based on this list.
#'
#' @author Hyun-Ho Yang
#'
#' @examples
#' \dontrun{
#' # with default settings.
#' MeCall.SetChainFile(remove.list = NULL, auto.remove = FALSE, global.env = TRUE)
#'
#' # To save the chain file from the user's file.
#' userfile <- user.dataframe.objects
#' Address_chain_file <- MeCall.SetChainFile(remove.list = userfile, auto.remove = TRUE, 
#' global.env = FALSE)
#' }
#'
#' @export MeCall.SetChainFile
MeCall.SetChainFile <- function(remove.list = NULL, auto.remove = FALSE, global.env = TRUE){

if(global.env){
message("\n[MeCall]-[NOTICE] : [global.env] parameter == TRUE. [Address_chain_file] will be imported to global R emvironment. MethylCallR will refer this file to convert array type.")
}else{
message("\n[MeCall]-[NOTICE] : [global.env] parameter == FALSE. [Address_chain_file] will be returned as a data frame object. Users may want save the object or assign this object to a variable named [Address_chain_file] to use it.")
}

if(is.null(remove.list)){
message("\n[MeCall]-[NOTICE] : There is no provided probe list to control duplicated probes in EPICv2.")
message("\n[MeCall]-[NOTICE] : MethylCallR will generate [Address_chain_file] based on the pre-set probe list implemented in MethylCallR.")
#data(Duplicated.Probes.preset)
remove.list <- Duplicated.Probes.preset

}else{
message("\n[MeCall]-[NOTICE] : MethylCallR will generate [Address_chain_file] based on the probe list provided by user.")
DUP.check <- RemoveDupCheck(remove.list)

if(!all(is.na(DUP.check))){
lists1 <- unlist(lapply(DUP.check, function(x){paste0("[",paste(x, collapse = ","),"]")}))
Warning.vec <- paste(lists1, collapse= ", ")
if(auto.remove){
message("\n[MeCall]-[NOTICE] : auto.remove == TRUE. Code will be remove Remained duplicated probe sets based on the pre-set data implemented in MethylCallR.")
MethylCallR_preset <- Duplicated.Probes.preset
Add.probes <- intersect(unlist(DUP.check), MethylCallR_preset)
Empty.m <- matrix(NA, ncol= ncol(remove.list), nrow = length(Add.probes))
rownames(Empty.m) <- Add.probes
remove.list <- rbind(remove.list, Empty.m)
}else{
stop("\n[MeCall]-!!ERROR!! : There are ",length(lists1)," duplicated probe sets : ", Warning.vec, ". Please check again.")}
}else{
message("\n[MeCall]-[NOTICE] : All duplicated probe sets were considered.")
}}

address_chain_file <- chainfile_generator(remove.list)

if(!global.env){
Return.obj <- list(Duplicated.Probes.preset = remove.list, Address_chain_file = address_chain_file)
return(Return.obj)}

Duplicated.Probes.preset <<- remove.list
Address_chain_file <<- address_chain_file
}



RemoveDupCheck <- function(rm.list){
#data(IlluminaHumanMethylationEPIC.V2a1.hg38)
Full.row <- rownames(IlluminaHumanMethylationEPIC.V2a1.hg38)
rm.row <- rownames(rm.list)
Remain.row <- setdiff(Full.row, rm.row)

EPICv2_peter_manifest <- Modified_EPICv2_manifest_in_TJ.Peters_BMCgenomics_2024
Rep_set <- subset(EPICv2_peter_manifest, !((seqrep_IlmnIDs == "") & (posrep_IlmnIDs == "")))

Rep_set_list <- lapply(c(1:nrow(Rep_set)), function(x) {
A <- unlist(str_split(Rep_set[x,"seqrep_IlmnIDs"], ";"))
A <- A[grep("cg", A)]
B <- unlist(str_split(Rep_set[x,"posrep_IlmnIDs"], ";"))
B <- B[grep("cg", B)]
Tot <- sort(union(A,B))
set_str <- paste0(Tot, collapse = ";")
return(set_str)})

Unique_Rep_sets <- names(table(unlist(lapply(Rep_set_list, function(x){paste(x,collapse=";")}))))

Unique_Rep_set_list <- lapply(c(1:length(Unique_Rep_sets)), function(x){
Rep_vec <- unlist(str_split(Unique_Rep_sets[x], ";"))
return(Rep_vec)})

Check_con_rep <- unlist(lapply(Unique_Rep_set_list, function(x){
Rmained <- length(setdiff(x, rm.row))
if(Rmained < 2){
TnF <- TRUE
}else{
TnF <- FALSE
}
return(TnF)}))

if(sum(!Check_con_rep) < 1){
checkresult <- NA
}else{
checkresult <-Unique_Rep_set_list[!Check_con_rep]
}

return(checkresult)}



chainfile_generator <- function(Dup_probe_set){

#data(IlluminaHumanMethylation450K)
#data(HM450.hg38.manifest)
#data(IlluminaHumanMethylationEPIC.V1b5.hg38)
#data(IlluminaHumanMethylationEPIC.V2a1.hg38)

v2_unique <- setdiff(rownames(IlluminaHumanMethylationEPIC.V2a1.hg38),rownames(Dup_probe_set))

HM450.hg38.manifest2 <- HM450.hg38.manifest[rownames(IlluminaHumanMethylation450K),]

mani_v2 <- IlluminaHumanMethylationEPIC.V2a1.hg38[v2_unique,]
mani_v1 <- IlluminaHumanMethylationEPIC.V1b5.hg38
mani_450 <- cbind(IlluminaHumanMethylation450K,HM450.hg38.manifest2[,1:3])


# [1] Find common probe among 3 types of microarray 
No1_list <- subset(mani_v2, EPICv1_Loci != "" & Methyl450_Loci != "")
No1_target <- subset(No1_list, Name != EPICv1_Loci | Name != Methyl450_Loci)

No1_target_V2nm_Ori <- rownames(No1_target)
No1_target_V2nm <- No1_target$Name

No1_list$EPICv1_Loci[which(str_detect(No1_list$EPICv1_Loci,";"))] <- "cg07596106"

No1_maniv2 <- mani_v2[rownames(No1_list),]
No1_maniv1 <- mani_v1[No1_list$EPICv1_Loci,]
No1_mani450 <- mani_450[No1_list$Methyl450_Loci,]

No1_maniv2_info <- No1_maniv2[,c(1:4,6)]
colnames(No1_maniv2_info) <- paste0("EPICv2_",colnames(No1_maniv2[,c(1:4,6)]))

No1_maniv1_info <- No1_maniv1[,c(1:3, 5, 4)]
colnames(No1_maniv1_info) <- paste0("EPICv1_",colnames(No1_maniv2[,c(1:4,6)]))

No1_mani450_info <- No1_mani450[,c(1:3, 5, 4)]
colnames(No1_mani450_info) <- paste0("Methyl450K_",colnames(No1_maniv2[,c(1:4,6)]))


No1_Full_info <- cbind(No1_maniv2_info, No1_maniv1_info, No1_mani450_info)


# [2] (common probe list between EPICv1 and EPICv2) - (probes in [1])
No2_list_ori <- subset(mani_v2, EPICv1_Loci != "")
No2_list <- No2_list_ori[setdiff(rownames(No2_list_ori),rownames(No1_list)),]

No2_list$EPICv1_Loci[which(str_detect(No2_list$EPICv1_Loci,";"))] <- "cg04213485"

No2_maniv2 <- mani_v2[rownames(No2_list),]
No2_maniv1 <- mani_v1[No2_list$EPICv1_Loci,]
No2_mani450 <- mani_450[No2_list$Methyl450_Loci,]

No2_maniv2_info <- No2_maniv2[,c(1:4,6)]
colnames(No2_maniv2_info) <- paste0("EPICv2_",colnames(No2_maniv2[,c(1:4,6)]))

No2_maniv1_info <- No2_maniv1[,c(1:3, 5, 4)]
colnames(No2_maniv1_info) <- paste0("EPICv1_",colnames(No2_maniv2[,c(1:4,6)]))

No2_Empty <- as.data.frame(matrix(NA, ncol = 5))
colnames(No2_Empty) <- paste0("Methyl450K_",colnames(No1_maniv2[,c(1:4,6)]))


No2_Full_info <- cbind(No2_maniv2_info, No2_maniv1_info, No2_Empty)


# [3] (common probe list between EPICv1 and 450K) - (probes in [1])
No3_list_ori <- subset(mani_v1, Methyl450_Loci == TRUE)
No3_only <- setdiff(No3_list_ori$Name,No1_Full_info$EPICv1_Name)

No3_list <- No3_list_ori[No3_only,]

No3_maniv1 <- mani_v1[No3_list$Name,]
No3_mani450 <- mani_450[No3_list$Name,]

No3_Empty <- as.data.frame(matrix(NA, ncol = 5))
colnames(No3_Empty) <- paste0("EPICv2_",colnames(No1_maniv2[,c(1:4,6)]))

No3_maniv1_info <- No3_maniv1[,c(1:3, 5, 4)]
colnames(No3_maniv1_info) <- paste0("EPICv1_",colnames(No1_maniv2[,c(1:4,6)]))

No3_mani450_info <- No3_mani450[,c(1:3, 5, 4)]
colnames(No3_mani450_info) <- paste0("Methyl450K_",colnames(No1_maniv2[,c(1:4,6)]))

No3_Full_info <- cbind(No3_Empty, No3_maniv1_info, No3_mani450_info)


# [4] (common probe list between EPICv2 and 450K) - (probes in [1])
No4_list_ori <- subset(mani_v2, Methyl450_Loci != "")
No4_only <- setdiff(rownames(No4_list_ori),rownames(No1_Full_info))

No4_list <- No4_list_ori[No4_only,]

No4_maniv2 <- mani_v2[rownames(No4_list),]
No4_mani450 <- mani_450[No4_list$Methyl450_Loci,]

No4_maniv2_info <- No4_maniv2[,c(1:4,6)]
colnames(No4_maniv2_info) <- paste0("EPICv2_",colnames(No1_maniv2[,c(1:4,6)]))

No4_Empty <- as.data.frame(matrix(NA, ncol = 5))
colnames(No4_Empty) <- paste0("EPICv1_",colnames(No1_maniv2[,c(1:4,6)]))

No4_mani450_info <- No4_mani450[,c(1:3, 5, 4)]
colnames(No4_mani450_info) <- paste0("Methyl450K_",colnames(No1_maniv2[,c(1:4,6)]))

No4_Full_info <- cbind(No4_maniv2_info, No4_Empty, No4_mani450_info)

# [5] [1] + [2] + [3] + [4]
Total_Chain_File <- rbind(No1_Full_info,No2_Full_info,No3_Full_info,No4_Full_info)
Total_Chain_File[,"EPICv2_Color_Channel"][which(Total_Chain_File[,"EPICv2_Color_Channel"] == "")] <- "G+R"


## Probes targeting the same CpG but with different channel colors are considered as "unique probes" for each platform and excluded from the chain file.
E2_E1_col_diff <- rownames(Total_Chain_File[which(Total_Chain_File$EPICv2_Color_Channel != Total_Chain_File$EPICv1_Color_Channel),][,c(4,9,14)])
E2_M450_col_diff <- rownames(Total_Chain_File[which(Total_Chain_File$EPICv2_Color_Channel != Total_Chain_File$Methyl450K_Color_Channel),][,c(4,9,14)])
E1_M450_col_diff <- rownames(Total_Chain_File[which(Total_Chain_File$EPICv1_Color_Channel != Total_Chain_File$Methyl450K_Color_Channel),][,c(4,9,14)])

Total_col_diff <- union(E2_E1_col_diff,E2_M450_col_diff)
Total_col_diff <- union(Total_col_diff,E1_M450_col_diff)

Mismatch_in_Chain_file <- Total_Chain_File[Total_col_diff,]

E2_rm <- which(is.na(Mismatch_in_Chain_file$EPICv2_Name))
E1_rm <- which(is.na(Mismatch_in_Chain_file$EPICv1_Name))
M450_rm <-which(is.na(Mismatch_in_Chain_file$Methyl450K_Name))

E2_na <- which(Mismatch_in_Chain_file$EPICv1_Color_Channel == Mismatch_in_Chain_file$Methyl450K_Color_Channel)

E1_na <- which(Mismatch_in_Chain_file$EPICv2_Color_Channel == Mismatch_in_Chain_file$Methyl450K_Color_Channel)

M450_na <- which(Mismatch_in_Chain_file$EPICv2_Color_Channel == Mismatch_in_Chain_file$EPICv1_Color_Channel)

Remove_name <- c(rownames(Mismatch_in_Chain_file[E1_rm,]),rownames(Mismatch_in_Chain_file[M450_rm,]))

Total_Chain_File <- Total_Chain_File[setdiff(rownames(Total_Chain_File), Remove_name),]

Total_Chain_File[rownames(Mismatch_in_Chain_file[E1_na,]),c(6:10)] <- NA
Total_Chain_File[rownames(Mismatch_in_Chain_file[E2_na,]),c(1:5)] <- NA

return(Total_Chain_File)}

