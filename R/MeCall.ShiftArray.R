#' Changing the version of the microarray.
#'
#' @description
#' This function utilizes the Chain file generated by MethylCallR to change 
#' the version of the microarray for the input object.
#'
#' Specifically, this chain file is designed to retain only features 
#' that are common across all array versions. For example, if probe X was 
#' a type 1 probe in EPICv1, and both type 1 and type 2 probes coexist 
#' in EPICv2, only the information related to the type 1 probe will 
#' be preserved. This is essential because it minimizes potential bias 
#' that can arise when using algorithms that consider differences in 
#' probe type or channel color. 
#'
#' The `MeCall.ShiftArray()` function supports inputs in the form of 
#' `minfi` objects (`RGChannelSet` and `MethylSet`), matrix, and vector. 
#' After changing the version, it returns an object in the same form as 
#' the inputted object.
#'
#' @param Object The object for which the version will be changed.
#' @param From The version of the inputted object.
#' @param To The version of the output object.
#' @param type The type of the inputted object (`rgSet`,`mSet`,`Matrix`,`Vector`).
#'
#' @return An object with the changed version that retains the same format as the input object.
#'
#' @author Hyun-Ho Yang
#'
#' @examples
#' \dontrun{
#' # Change array version from EPICv2 to EPICv1
#' Shifted.rgSet <- MeCallR.ShiftArray(Object = data.Import$minfi.Set$rgSet, From = "EPICv2", 
#' To = "EPICv1", type = c("rgSet"))
#' }
#'
#' @export MeCallR.ShiftArray
MeCallR.ShiftArray <- function(Object, From = "EPICv2", To = "EPICv1", type = c("rgSet","mSet","Matrix","Vector")){
message("\n[MeCall]-[NOTICE] : Converting the array type from ",From," to ",To,".")

message("\n[MeCall]-[NOTICE] : Converted ",type," will be returned.")

if(type == "rgSet"){
message("\n[MeCall]-[NOTICE] : Converting the array type using probe address chain file.")
Shifted_obj <- MeCallR.ShiftArray_rgSet(Object, From = "EPICv2", To = "EPICv1")
}

if(type == "mSet" | type == "Matrix"){
message("\n[MeCall]-[NOTICE] : Converting the array type using common probe ID.")
Shifted_obj <- MeCallR.ShiftArray_mSet(Object, From = "EPICv2", To = "EPICv1")
}

if(type == "Vector"){
message("\n[MeCall]-[NOTICE] : Converting the array type using common probe ID.")
Shifted_obj <- MeCallR.ShiftArray_vec(Object, From = "EPICv2", To = "EPICv1")
}
return(Shifted_obj)}



MeCallR.ShiftArray_mSet <- function(Object, From = "EPICv2", To = "EPICv1") {
#data(Combine_array_index)

if(From == "EPICv2"){
Remains <- setdiff(rownames(Object), rownames(Duplicated.Probes.preset))
Nrownm <- unlist(lapply(Remains, function(x){strsplit(x,split="_")[[1]][1]}))
if(is(Object, "MethylSet")){
Object@assays@data@listData$Meth <- Object@assays@data@listData$Meth[Remains,]
Object@assays@data@listData$Unmeth <- Object@assays@data@listData$Unmeth[Remains,]
rownames(Object@assays@data@listData$Meth) <- Nrownm
rownames(Object@assays@data@listData$Unmeth) <- Nrownm
Object@NAMES <- rownames(Object@assays@data@listData$Meth)
} else {
Object <- Object[Remains, ]
rownames(Object) <- Nrownm
}
}

if(To =="450K"){
rg.annotation <- c(array="IlluminaHumanMethylation450k", annotation="ilmn12.hg19")
} else if (To =="EPICv1"){
rg.annotation <- c(array="IlluminaHumanMethylationEPIC", annotation="ilm10b4.hg19")
} else {
rg.annotation <- c(array="IlluminaHumanMethylationEPICv2", annotation="20a1.hg38")
}

Fr.Name <- grep(From, colnames(Address_chain_file))[1]
To.Name <- grep(To, colnames(Address_chain_file))[1]

Shift_To <- Address_chain_file[which(Address_chain_file[,Fr.Name] != Address_chain_file[,To.Name]),To.Name]

Shift_From <- Address_chain_file[which(Address_chain_file[,Fr.Name] != Address_chain_file[,To.Name]),Fr.Name]

names(Shift_To) <- Shift_From

if(is(Object, "MethylSet")){
Obj.NAMES <- Object@NAMES
} else {
Obj.NAMES <- rownames(Object)
}

Target.idx <- which(Obj.NAMES %in% Shift_From)

for (i in c(1:length(Target.idx))){
        Obj.NAMES[Target.idx[i]] <- unname(Shift_To[Obj.NAMES[Target.idx[i]]])
}


if(is(Object, "MethylSet")){
Object@NAMES <- Obj.NAMES
rownames(Object@assays@data@listData$Meth) <- Obj.NAMES
rownames(Object@assays@data@listData$Unmeth) <- Obj.NAMES
Object@annotation <- rg.annotation
} else {
rownames(Object) <- Obj.NAMES
}


To.mani <- callmanifest(To)
Common <- intersect(Obj.NAMES, rownames(To.mani))

if(is(Object, "MethylSet")){
Object@NAMES <- Common
Object@assays@data@listData$Meth <- Object@assays@data@listData$Meth[Common,]
Object@assays@data@listData$Unmeth <- Object@assays@data@listData$Unmeth[Common,]
Object@elementMetadata@nrows <- length(Common)
} else {
Object <- Object[Common,]
}

return(Object)}

MeCallR.ShiftArray_rgSet <- function(rgSet = rgSet, From = "EPICv2", To = "EPICv1"){ # Revised

if(!exists("Address_chain_file")){
message("\n[MeCall]-[NOTICE] : [Address_chain_file] is not founded. MethylCallR automatically generates [Address_chain_file] by using data implemented in MethylCallR.")
message("\n[MeCall]-[NOTICE] : If user want to generate own chain file, please see description of `MeCall.SetChainFile()` for detail.")
MeCall.SetChainFile()
}

#data(Control_probe_chain_file)

if(From == "EPICv2"){
rgSet <- ReShapergSetObj(rgSet, Duplicated.Probes.preset)
}

Fr.cols <- colnames(Address_chain_file)[grepl(From, colnames(Address_chain_file))]

To.cols <- colnames(Address_chain_file)[grepl(To, colnames(Address_chain_file))]


Chain_file <- Address_chain_file[,c(Fr.cols, To.cols)]

Chain_file <- subset(Chain_file, !is.na(Chain_file[,Fr.cols[1]]) & !is.na(Chain_file[,To.cols[1]]))

Cprobe <- subset(Chain_file, Chain_file[,Fr.cols[5]] == Chain_file[,To.cols[5]] & Chain_file[,Fr.cols[4]] == Chain_file[,To.cols[4]])

# Consider as a unique probe in [From]array 
Sprobe <- subset(Chain_file, Chain_file[,Fr.cols[5]] != Chain_file[,To.cols[5]] | Chain_file[,Fr.cols[4]] != Chain_file[,To.cols[4]])

obj_RGset <- rgSet
TRUE.Grow <- rownames(obj_RGset@assays@data@listData$Green)
TRUE.Rrow <-rownames(obj_RGset@assays@data@listData$Red)


TyII <- subset(Cprobe, Cprobe[,Fr.cols[5]] == "II")
TyI.R <- subset(Cprobe, Cprobe[,Fr.cols[5]] == "I" & Cprobe[,Fr.cols[4]] == "Red")
TyI.G <- subset(Cprobe, Cprobe[,Fr.cols[5]] == "I" & Cprobe[,Fr.cols[4]] == "Grn")


Cp.subset <- subset(Control_probe_chain_file, !is.na(Control_probe_chain_file[,1]))
Fr.controls <- Cp.subset[,"EPIC_address"]
To.controls <- Cp.subset[,"EPIC_address"]
if(From == "450K"){
Cp.subset <- subset(Control_probe_chain_file, !is.na(Control_probe_chain_file[,1]) & !is.na(Control_probe_chain_file[,5]))
Fr.controls <- Cp.subset[,"Methyl450K_address"]
To.controls <- Cp.subset[,"EPIC_address"]
}

if(To == "450K"){
Cp.subset <- subset(Control_probe_chain_file, !is.na(Control_probe_chain_file[,1]) & !is.na(Control_probe_chain_file[,5]))
Fr.controls <- Cp.subset[,"EPIC_address"]
To.controls <- Cp.subset[,"Methyl450K_address"]
}

Cp.idx <- which(Fr.controls %in% TRUE.Grow)


From.Total.Address <- c(TyII[,Fr.cols[2]], TyI.G[,Fr.cols[2]], TyI.G[,Fr.cols[3]],TyI.R[,Fr.cols[2]], TyI.R[,Fr.cols[3]],Fr.controls[Cp.idx])

To.Total.Address <- c(TyII[,To.cols[2]], TyI.G[,To.cols[2]], TyI.G[,To.cols[3]],TyI.R[,To.cols[2]], TyI.R[,To.cols[3]],To.controls[Cp.idx])


After.Shift.Grn <- obj_RGset@assays@data@listData$Green[From.Total.Address,]
After.Shift.Red <- obj_RGset@assays@data@listData$Red[From.Total.Address,]

rownames(After.Shift.Grn) <- To.Total.Address
rownames(After.Shift.Red) <- To.Total.Address

Shifted_RGset <- obj_RGset

if(To == "450K"){
Shifted.annotation <- c(array="IlluminaHumanMethylation450k", annotation="ilmn12.hg19")
} else if(To == "EPICv1"){
Shifted.annotation <- c(array="IlluminaHumanMethylationEPIC", annotation="ilm10b4.hg19")
} else {
Shifted.annotation <- c(array="IlluminaHumanMethylationEPICv2", annotation="20a1.hg38")
}

Shifted_RGset@assays@data@listData$Green <- After.Shift.Grn
Shifted_RGset@assays@data@listData$Red <- After.Shift.Red
Shifted_RGset@NAMES <- as.character(To.Total.Address)
Shifted_RGset@annotation <- Shifted.annotation
Shifted_RGset@elementMetadata@nrows <- length(To.Total.Address)

return(Shifted_RGset)}




MeCallR.ShiftArray_vec <- function(Object, From = "EPICv2", To = "EPICv1"){

if(!exists("Address_chain_file")){
message("\n[MeCall]-[NOTICE] : [Address_chain_file] is not founded. MethylCallR automatically generates [Address_chain_file] by using data implemented in MethylCallR.")
message("\n[MeCall]-[NOTICE] : If user want to generate own chain file, please see description of `MeCall.SetChainFile()` for detail.")
MeCall.SetChainFile()
}

Fr.cols <- colnames(Address_chain_file)[grepl(From, colnames(Address_chain_file))]

To.cols <- colnames(Address_chain_file)[grepl(To, colnames(Address_chain_file))]

Name.df <- subset(Address_chain_file, !is.na(Address_chain_file[,Fr.cols[1]]) & !is.na(Address_chain_file[,To.cols[1]]))

if(From == "EPICv2"){
Object <- setdiff(Object, rownames(Duplicated.Probes.preset))
}

Fr.Vec <- intersect(rownames(Name.df),Object)
Name.df.sub <- Name.df[Fr.Vec,]
Shifted.vec <- Name.df.sub[,To.cols[1]]

return(Shifted.vec)}

