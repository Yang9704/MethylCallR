#' Filtering samples and probes under various conditions for quality control
#'
#' @import minfi
#' @import robustbase
#'
#'
#'
#' @description
#' Removes samples and CpG sites with poor conditions.
#'
#' Sample filtering was based on the `minfi` R package, 
#' while probe filtering was based on the `ChAMP` R package.
#' 
#' Additionally, MethylCallR provides options to remove FLAG probes 
#' and mapping failed probes.
#'
#' FLAG probes have a low replication rate that does not meet the 
#' manufacturer's quality control criteria (`FLAG`).
#' Mapping failed probes have an ambiguous position in the GRCh38/hg38 genome,
#' while positions are provided in GRCh37/hg19 (`hg38.mapfail`).
#' 
#' If these options are set to TRUE, MethylCallR will remove these probes 
#' according to the manifest provided by Illumina and add them to the 
#' `filtered.CpG.list`.
#'
#' If your data uses the microarray version EPICv2, we recommend setting the
#' `RemoveDup` parameter to `MethylCallR`. Setting this parameter to `MethylCallR` will ensure 
#' that duplicated probes in EPICv2 are selected to maintain characteristics 
#' similar to those in the previous microarray version. For example, 
#' if probe X was a type 1 probe in EPICv1, and both type 1 and type 2 probes
#' coexist in EPICv2, only the information related to the type 1 probe will be 
#' preserved.
#' 
#' The relevant data (`Duplicated.Probes.preset`) were generated by 
#' selecting probes with characteristics that do not match between two 
#' versions (EPICv2 and EPICv1) of the Illumina manifest through comparison.
#'
#' @param data A return object from `MeCall.ReadIdat()`
#' @param RemoveDup Option for EPICv2 data. When set to `MethylCallR`, code removes duplicated probes and generate `Address_chain_file` based on the data implemented in MethylCallR. If user provides customized data, code will remove duplicated probes based on the user data. If it set to `none`, code will skip this step.
#' @param badSample.minfi Logical. The sample filtering method implemented in the minfi R package is applied. The quality of each sample will be assessed based on the median of log-scaled intensity values.
#' @param badSampleCutoff.minfi Samples with values below the threshold are removed.
#' @param detectionP Logical. Filtering probes based on detection P-value matrix.
#' @param detP.probe.cutoff Probes with detection P-values above the threshold are removed.
#' @param detP.sample.cutoff Samples with a proportion of failed probes in detection P-value criteria above the threshold are removed.
#' @param detP.failed.ratio Detection P-value failed probes with a proportion above the threshold among the entire sample are removed. For example, if detP.failed.ratio = 0, any probe that fails the detection P-value criterion in at least one sample is removed from downstream analysis.
#' @param beadcount Logical. Filtering probes based on beadcount matrix.
#' @param beadcutoff Probes with a bead count of less than 3 are removed if the probe has a proportion above the threshold in the entire sample.
#' @param NoCG Logical. Probes that are not CG are removed.
#' @param SNPmask Logical. Probes located near SNPs of the selected population are removed
#' @param population SNPmask filtering is based on the selected population. ('General', 'AFR', 'EAS', 'EUR', 'SAS', 'AMR', 'GWD', 'YRI', 'TSI', 'IBS', 'CHS', 'PUR', 'JPT', 'GIH', 'CHASK', 'STU', 'ITU', 'LWK', 'KHV', 'FIN', 'ESN', 'CEU', 'PJL', 'ACASK', 'CLM', 'CDX', 'GBR', 'BEASK', 'PEL', 'MSL', 'MXL', 'ASW').
#' @param Multihit Logical. Probes with multiple aligned sequences will be removed.
#' @param Multihit.method Setting the criteria for removing cross-hybridizing probes. Use "WGBS" to remove probes that show stronger affinity for non-target sites identified by comparing to whole-genome bisulfite sequencing. Use "BLAT" to remove all probes with in silico cross-hybridization events predicted at least once by BLAT (default = "WGBS"). See (TJ Peters et al., 2024) for detail.
#' @param Sexchr Character. Probes existing on the selected sex chromosome are removed.
#' @param FLAG Logical. Filtering out probes with a low replication rate that does not meet the manufacturer's quality control criteria.
#' @param hg38.mapfail Logical. Filtering out probes with an ambiguous position in the GRCh38/hg38 reference genome.
#'
#' @return A list object containing basic informations with filtered CpG sites 
#' to process methylation microarray. Return object of `MeCall.Filtering()` has
#' the similar structure as the `MeCall.ReadIdat()` function. 
#' All filtered-out sample and probe names will be added to 
#' `filtered.Sample.list` and `filtered.CpG.list`, respectively, and returned
#' together in the return object.
#'
#' @author Hyun-Ho Yang
#'
#' @seealso [minfi::getQC()], [ChAMP::champ.filter()], [MeCall.ReadIdat()]
#'
#' @references 
#' Aryee, M.J. et al. (2014). Minfi: a flexible and comprehensive Bioconductor package for the 
#' analysis of Infinium DNA methylation microarrays. Bioinformatics. 
#' \url{https://doi.org/10.1093/bioinformatics/btu049}
#'
#' Tian, Y. et al. (2017). ChAMP: updated methylation analysis pipeline for Illumina BeadChips. 
#' Bioinformatics. \url{https://doi.org/10.1093/bioinformatics/btx513}
#'
#' For Multihit probes (EPICv1 and 450K)
#' Nordlund, J. et al. (2013). Genome-wide signatures of differential DNA methylation in pediatric
#' acute lymphoblastic leukemia. Genome Biology. \url{https://doi.org/10.1186/gb-2013-14-9-r105}
#'
#' For Multihit probes (EPICv2) and mismatch probes
#' Peters, T.J. et al. (2024). Characterisation and reproducibility of the HumanMethylationEPIC 
#' v2.0 BeadChip for DNA methylation profiling. BMC Genomics. 
#' \url{https://doi.org/10.1186/s12864-024-10027-5}
#'
#' For SNP associated probes
#' Zhou, W. et al. (2017). Comprehensive characterization, annotation and innovative use of 
#' Infinium DNA methylation BeadChip probes. Nucleic Acids Research. 
#' \url{https://doi.org/10.1093/nar/gkw967}
#'
#'
#' @examples
#' \dontrun{
#' # To run filtering function with default setting.
#' data.filtered <- MeCall.filtering(data = data.Import, badSample.minfi = TRUE, 
#' badSampleCutoff.minfi = 10.5, detectionP = TRUE, detP.probe.cutoff = 0.01, 
#' detP.sample.cutoff = 0.1, detP.failed.ratio = 0, beadcount = TRUE, beadcutoff = 0.05, 
#' NoCG = TRUE, SNPmask = TRUE, population = "General", Multihit = TRUE, Sexchr = "XY", 
#' FLAG = TRUE, hg38.mapfail = TRUE)
#'
#' # Or just
#' data.filtered <- MeCall.Filtering(data = data.Import)
#' }
#'
#' @export
MeCall.Filtering <- function(data = Idat.list, RemoveDup = "MethylCallR", badSample.minfi = TRUE, badSampleCutoff.minfi = 10.5, detectionP = TRUE, detP.probe.cutoff = 0.01, detP.sample.cutoff = 0.1, detP.failed.ratio = 0, beadcount = TRUE, beadcutoff = 0.05, NoCG = TRUE, SNPmask = TRUE, population = "General", Multihit = TRUE, Multihit.method = "WGBS" ,Sexchr = "XY", FLAG = TRUE, hg38.mapfail = TRUE){
message("\n[MeCall]-[notice] : Running probe filtering procedure.")
platform <- data$TAG

if(!platform %in% c("450K","EPICv1","EPICv2")){
stop("\n[MeCall]-!!ERROR!! : ",platform," : Unknown Array platform.")
}else{mani <- callmanifest(platform)}

population <- match.arg(population, c('AFR', 'EAS', 'EUR', 'SAS', 'AMR', 'GWD', 'YRI', 'TSI', 'IBS', 'CHS', 'PUR', 'JPT', 'GIH', 'CHASK', 'STU', 'ITU', 'LWK', 'KHV', 'FIN', 'ESN', 'CEU', 'PJL', 'ACASK', 'CLM', 'CDX', 'GBR', 'BEASK', 'PEL', 'MSL', 'MXL', 'ASW', 'General'), several.ok = TRUE)

# Re-shaping EPICv2
Duplicated.probes <- c()
if(platform == "EPICv2"){
if(RemoveDup == "none"){
message("\n[MeCall]-[notice] : Array type : EPICv2 / RemoveDup = FALSE")
message("\n[MeCall]-[notice] : Duplicated probes will not be removed.")
Duplicated.probes <- c()
} else if(RemoveDup == "MethylCallR"){
message("\n[MeCall]-[notice] : Array type : EPICv2 / RemoveDup = TRUE")
message("\n[MeCall]-[notice] : Remove duplicated probes using MethylCallR data.")
MeCall.SetChainFile()
Duplicated.probes <- rownames(Duplicated.Probes.preset)
data <- ReShapeImportObj(data, Duplicated.Probes.preset)
}else {
message("\n[MeCall]-[notice] : Array type : EPICv2 / RemoveDup = TRUE")
message("\n[MeCall]-[notice] : Remove duplicated probes using user provided data.")

if(!is.data.frame(RemoveDup)){
stop("\n[MeCall]-!!ERROR!! : The `RemoveDup` parameter should be a dataframe. Please refer the `data(Duplicated.Probes.preset)` to make user customized list. User may want to set the `RemoveDup` parameter in `MethylCallR` to use the list provided by MethylCallR.")
}

MeCall.SetChainFile(remove.list = RemoveDup)
Duplicated.probes <- rownames(RemoveDup)
data <- ReShapeImportObj(data, RemoveDup)
}
}


detectM <- data$detP
Bcount <- data$B.count
intensity <- data$intensity

# minfi sample QC process
if(badSample.minfi){
message("\n[MeCall]-[notice] : Filtering samples using median value of signal intensity. This process and code are builded based on QC process in minfi R package.")
suppressWarnings({mS <- minfi::fixMethOutliers(data$minfi.Set$mSet)
Mmat <- mS@assays@data@listData$Meth
Umat <- mS@assays@data@listData$Unmeth
M.medians <- log2(robustbase::colMedians(Mmat))
U.medians <- log2(robustbase::colMedians(Umat))})
meds <- (M.medians + U.medians)/2
names(meds) <- colnames(Mmat)
minfi.QC.bad.samples <- names(meds[which(meds <= badSampleCutoff.minfi)])
}else{
minfi.QC.bad.samples <- c()
}
#1. detection P-value
if(detectionP){
message("\n[MeCall]-[notice] : Filtering probes with detection P-value criteria.")
message("                      1. detection P-value greater than [",detP.probe.cutoff,"]")
message("                      2. The sample with the greater percentage of probes defined as detection p-value failures ( > ",(detP.sample.cutoff*100),"%)")
message("                      3. having CpGs in at least [",(detP.failed.ratio*100),"]% of the samples")
detectM[detectM > detP.probe.cutoff] <- NA
detect.fail.sample <- unlist(apply(detectM,2,function(x){sum(is.na(x))/nrow(detectM)}))
Failed.sample <- names(detect.fail.sample[detect.fail.sample >= detP.sample.cutoff])
Failed.sample <- unique(c(minfi.QC.bad.samples,Failed.sample))
Remain.sample <- setdiff(colnames(detectM), Failed.sample)
if(length(Failed.sample) != 0){
message("\n[MeCall]-!!CAUSION!! : ",length(Failed.sample)," samples with high proportion of poor CpGs will be eliminated for downstream analysis.")
message("\n[MeCall]-!!CAUSION!! : ",length(Remain.sample)," samples left.")
}
detect.failed <- unlist(apply(detectM,1,function(x){sum(is.na(x))/ncol(detectM)}))
if(detP.failed.ratio == 0){detectP.probe <- setdiff(rownames(detectM),rownames(detectM[complete.cases(detectM), ]))
}else if(detP.failed.ratio > 1){stop("\n[MeCall]-!!ERROR!! : detP.failed.ratio parameter must be in range of 0 ~ 1.")
}else{detectP.probe <- names(detect.failed[detect.failed >= detP.failed.ratio])
}}else{
detectP.probe <- c()}

#2. beadcount
if(beadcount){
message("\n[MeCall]-[notice] : Filtering probes with beadcount criteria.")
message("                      1. having beadcount < 3 in at least [",(beadcutoff*100),"]% of the samples")
props <- unlist(apply(Bcount,1,function(x){prop <- sum(is.na(x))/length(x)}))
props[props >= beadcutoff] <- NA
Bcount.probe <- names(props[is.na(props)])
}else{
Bcount.probe <-c()}

#3. NoCG
if(NoCG){
message("\n[MeCall]-[notice] : Filtering No CG probes.")
NoCG.probe <- rownames(as.matrix(intensity[!grepl('cg', rownames(intensity)), ]))
}else{
NoCG.probe <-c()}

#4. SNP related
if(SNPmask){
message("\n[MeCall]-[notice] : Filtering SNP associated probes based on the [SeSaMe] SNP population manifest.")
pop_list <- c('AFR', 'EAS', 'EUR', 'SAS', 'AMR', 'GWD', 'YRI', 'TSI', 'IBS', 'CHS', 'PUR', 'JPT', 'GIH', 'CHASK', 'STU', 'ITU', 'LWK', 'KHV', 'FIN', 'ESN', 'CEU', 'PJL', 'ACASK', 'CLM', 'CDX', 'GBR', 'BEASK', 'PEL', 'MSL', 'MXL', 'ASW')
if(platform == "EPICv2"){
#data(SNPmask.EPICv2)
if(population =="General"){message("\n[MeCall]-[notice] : Selected population : [general]")
SNPmask.probes <- rownames(subset(SNPmask.EPICv2,M_general == TRUE)) ##240701
SNPmask.probes <- intersect(rownames(intensity),SNPmask.probes)
}else{
message("\n[MeCall]-[notice] : Selected population : [",paste(population,collapse = ", "),"]") ##
SNPmask.probes <- c() ##
for (i in c(1:length(population))){ ##
Cols <- colnames(SNPmask.EPICv2) ## 
Subs <- SNPmask.EPICv2[,grep(population[i], Cols)] ##
Target <- names(Subs[Which(Subs == TRUE)]) ##
SNPmask.probes <- c(SNPmask.probes, Target) ##
}
Gen.probes <- rownames(subset(SNPmask.EPICv2,M_general == TRUE)) ##
SNPmask.probes <- intersect(rownames(intensity),unique(c(SNPmask.probes, Gen.probes))) ##
#popSNP <- rownames(SNPmask.EPICv2[TRUE,paste0('MASK_',population)])
#ComSNP <- rownames(subset(SNPmask.EPICv2,common == TRUE))
#Mask.map <- rownames(subset(SNPmask.EPICv2,MASK_map == TRUE))
#Mask.nonuniq <- rownames(subset(SNPmask.EPICv2,MASK_noUniq == TRUE))
#SNPmask.probes <- unique(c(ComSNP,Mask.map,Mask.nonuniq,popSNP))
}
}else if(platform == "EPICv1"){
#data(SNPmask.EPICv1)
if(population =="General"){message("\n[MeCall]-[notice] : Selected population : [general]")
SNPmask.probes <- rownames(subset(SNPmask.EPICv1,M_general == TRUE))
SNPmask.probes <- intersect(rownames(intensity),SNPmask.probes)
}else{
message("\n[MeCall]-[notice] : Selected population : [",paste(population,collapse = ", "),"]")
SNPmask.probes <- c()
for (i in c(1:length(population))){
Cols <- colnames(SNPmask.EPICv1)
Subs <- SNPmask.EPICv1[,grep(population[i], Cols)]
Target <- names(Subs[Which(Subs == TRUE)])
SNPmask.probes <- c(SNPmask.probes, Target)
}
Gen.probes <- rownames(subset(SNPmask.EPICv1,M_general == TRUE))
SNPmask.probes <- intersect(rownames(intensity),unique(c(SNPmask.probes, Gen.probes)))
}
}else if(platform == "450K"){
#data(SNPmask.450K)
if(population =="General"){message("\n[MeCall]-[notice] : Selected population : [general]")
SNPmask.probes <- rownames(subset(SNPmask.450K,M_general == TRUE))
SNPmask.probes <- intersect(rownames(intensity),SNPmask.probes)
}else{
message("\n[MeCall]-[notice] : Selected population : [",paste(population,collapse = ", "),"]")
SNPmask.probes <- c()
for (i in c(1:length(population))){
Cols <- colnames(SNPmask.450K)
Subs <- SNPmask.450K[,grep(population[i], Cols)]
Tot <- apply(Subs,1,sum)
Targets <- rownames(Subs[which(Tot > 1), ])
SNPmask.probes <- c(SNPmask.probes, Targets)
}}
Gen.probes <- rownames(subset(SNPmask.450K,M_general == TRUE))
SNPmask.probes <- intersect(rownames(intensity),unique(c(SNPmask.probes, Gen.probes)))
}else{stop("\n[MeCall]-!!ERROR!! : Platform type unknown. Please check 'TAG' slot in your data.")}
}else{SNPmask.probes <- c()}


#5. Multihit 
if(Multihit){
message("\n[MeCall]-[notice] : Filtering Multi-hit probes based on published papers.")
#data(EPIC.MultiHit.Nordlund_GenomeBiology_2013)
#data(Modified_EPICv2_manifest_in_TJ.Peters_BMCgenomics_2024)
Pfx.col <- platform
if(platform == "450K"){
Pfx.col <- "K450"
}
if(Multihit.method == "BLAT"){
message("\n[MeCall]-[notice] : MultiHit Method == 'BLAT'. All probes with in silico cross-hybridization events predicted by BLAT are removed.")
Peters.Multihit <- subset(Modified_EPICv2_manifest_in_TJ.Peters_BMCgenomics_2024, CH_BLAT == "Y")
}else{
message("\n[MeCall]-[notice] : MultiHit Method == 'WGBS'. As recommended by the authors, probes with a stronger affinity for non-target sites are removed.")
Peters.Multihit <- subset(Modified_EPICv2_manifest_in_TJ.Peters_BMCgenomics_2024, CH_WGBS_evidence == "Y")
}
if(platform == "EPICv2"){
Multihit.IDs <- rownames(Peters.Multihit)
}
if(platform == "EPICv1" | platform == "450K"){
IDcols <- grep(Pfx.col, colnames(Modified_EPICv2_manifest_in_TJ.Peters_BMCgenomics_2024))[1]
Nordlund.Multihit_ID <- rownames(EPIC.MultiHit.Nordlund_GenomeBiology_2013)
Peters.Multihit_ID <- unique(Peters.Multihit[which(!is.na(Peters.Multihit[,IDcols])),][,IDcols])
Multihit.IDs <- unique(c(Nordlund.Multihit_ID, Peters.Multihit_ID))
}
Multihit.probes <- intersect(rownames(intensity), Multihit.IDs)
}else{
Multihit.probes <- c()
}

#6. Sex chromosome
if(Sexchr == FALSE){
sexchr.probe <- c()
}else if(Sexchr != FALSE){
if(platform == "EPICv2"){
Xlist <- rownames(subset(mani, CHR == "chrX"))
Ylist <- rownames(subset(mani, CHR == "chrY"))
}else if(platform == "EPICv1"){
Xlist <- rownames(subset(mani, CHR == "X"))
Ylist <- rownames(subset(mani, CHR == "Y"))
}else if(platform == "450K"){
Xlist <- rownames(subset(mani, CHR == "X"))
Ylist <- rownames(subset(mani, CHR == "Y"))
}else{stop("\n[MeCall]-!!ERROR!! : platform information is unknown. Please check 'TAG' slot of your input data")
}
if(Sexchr == "X"){
message("\n[MeCall]-[notice] : Filtering CpG sites on sex chromosome. [chrX]")
sexchr.probe <- Xlist
}else if(Sexchr == "Y"){
message("\n[MeCall]-[notice] : Filtering CpG sites on sex chromosome. [chrY]")
sexchr.probe <- Ylist
}else if(Sexchr =="XY"){
message("\n[MeCall]-[notice] : Filtering CpG sites on sex chromosome. [chrX + chrY]")
sexchr.probe <- c(Xlist , Ylist)
}else if(!Sexchr == NA){stop("\n[MeCall]-!!ERROR!! : Unknown Sexchr parameter. You may select 'X', 'Y' or 'XY'")
}else{sexchr.probe <- c()}
}else{sexchr.probe <- c()}

#7. FLAGed probes
if(FLAG){

if(platform == "EPICv2"){
message("\n[MeCall]-[notice] : Filtering FLAG probes in [EPIC v2] manifest. In EPICv2, it refers to probes that did not meet the reproducibility threshold in the manufacturer's internal quality control.")
#data(FLAGprobes)
FLAG.probe <- rownames(FLAGprobes)
}else if(platform=="EPICv1"){
message("\n[MeCall]-[notice] : Filtering FLAG probes in [EPIC v1] manifest. In EPICv1, it refers to probes for which a decrease in quality was observed due to changes in probe (B1 ~ B5).")
FLAG.probe <- rownames(subset(mani, MFG_Change_Flagged == 1))
}else if(platform=="450K"){
message("\n[MeCall]-[notice] : 450K platform has no FLAG probes.")
FLAG.probe <- c()
}else{FLAG.probe <- c()}

}else{FLAG.probe <- c()}

#8. mapping failed and mismatch probes
if(hg38.mapfail){
message("\n[MeCall]-[notice] : Filtering GRCh38/hg38 mapping failed probes in Illumina manifest and mismatch probes with Sesame manifest.")
if(platform == "EPICv1"){
#data(V1b5.hg38.mapping.fail)
MapFail.probe <- rownames(V1b5.hg38.mapping.fail)
}else if(platform == "EPICv2"){ ##
#data(Modified_EPICv2_manifest_by_TJ.Peters)
MapFail.probe <- rownames(subset(Modified_EPICv2_manifest_in_TJ.Peters_BMCgenomics_2024, MismatchPos == "Y"))
}else if(platform == "450K"){
message("\n[MeCall]-[notice] : Since the Illumina manifest does not provide the position of the GRCH38/hg38 reference genome for 450K probes, only the Sesame manifest will be used for filtering.")
#data(hg38.mapping.fail.450K)
MapFail.probe <- rownames(hg38.mapping.fail.450K)
}else{MapFail.probe <- c()}
}else{MapFail.probe <- c()}

Elim.CpGs <- unique(c(detectP.probe, Bcount.probe, NoCG.probe,SNPmask.probes, Multihit.probes,sexchr.probe,FLAG.probe,MapFail.probe,Duplicated.probes))
message("\n[MeCall]-[notice] : Filtering procudure done.")
message("\n[MeCall]-[notice] : The number of samples removed : [",length(Failed.sample),"]")
message("\n[MeCall]-[notice] : The number of CpGs removed by criteria of detection p-value : [",length(unique(detectP.probe)),"]")
message("                                                              Bead Count : [",length(unique(Bcount.probe)),"]")
message("                                                              No CG region : [",length(unique(NoCG.probe)),"]")
message("                                                              SNP associated CpGs : [",length(unique(SNPmask.probes)),"]")
message("                                                              Multi-Hit CpGs : [",length(unique(Multihit.probes)),"]")
message("                                                              Sex chromosome CpGs : [",length(unique(sexchr.probe)),"]")
message("                                                              FLAGed CpGs : [",length(unique(FLAG.probe)),"]")
message("                                                              GRCh38/hg38 Mapping failed CpGs : [",length(unique(MapFail.probe)),"]")
if(platform == "EPICv2"){
message("                                                              Duplicated probes in EPICv2 : [",length(unique(Duplicated.probes)),"]")}
message("\n[MeCall]-[notice] : Total number of filtered out CpGs : [",length(Elim.CpGs),"]")
Remain.CpGs <- setdiff(rownames(intensity), Elim.CpGs)
message("\n[MeCall]-[notice] : Total number of remained samples : [",(ncol(intensity) - length(Failed.sample)),"]")
message("                                    remained CpGs : [",length(Remain.CpGs),"]")

beta <- data$beta[Remain.CpGs,Remain.sample]
M <- data$M[Remain.CpGs,Remain.sample]
intensity <- intensity[Remain.CpGs,Remain.sample]
Meth <- data$Meth[Remain.CpGs,Remain.sample]
Unmeth <- data$Unmeth[Remain.CpGs,Remain.sample]
pd <- data$pd[Remain.sample,]
rgset <- rmFailedSample(data$minfi.Set$rgSet, Remain.sample)
mset <- rmFailedSample(data$minfi.Set$mSet, Remain.sample)
Elim.Sam <- Failed.sample
Elim.CpGs <- list(detectP = detectP.probe, B.count=Bcount.probe, NoCG = NoCG.probe, SNP.associated = SNPmask.probes, Multi.hit = Multihit.probes, Sex.chromosome = sexchr.probe, FLAG = FLAG.probe, hg38.mapping.fail = MapFail.probe, Duplicated.probes = Duplicated.probes)

out <- list(beta=beta, M=M, intensity= intensity, Meth=Meth, Unmeth=Unmeth, pd=pd,TAG = platform,minfi.Set=list(rgSet = rgset, mSet = mset), filtered.Sample.list = Elim.Sam, filtered.CpG.list = Elim.CpGs)
return(out)}

